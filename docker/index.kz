// @korulang/docker - Docker DSL for Koru
//
// Declarative image definitions and typed container lifecycle.
// Phantom obligations ensure containers are properly stopped.
//
// DECLARATIVE IMAGES:
//   ~koru.docker:image(tag: "myapp:latest") {
//       FROM node:18-alpine
//       WORKDIR /app
//       COPY . .
//       RUN npm install
//       CMD ["node", "server.js"]
//   }
//
// Then run: koruc main.kz docker build
// This generates Dockerfiles and builds all declared images.

~import "$std/build"
~import "$std/deps"
~import "$std/compiler"

// System dependency: Docker CLI must be installed
~std.deps:requires.system {
    "name": "docker",
    "check": "docker --version",
    "brew": "docker",
    "apt": "docker.io",
    "dnf": "docker",
    "pacman": "docker",
    "apk": "docker"
}

// ============================================================================
// DOCKER BUILD COMMAND - Build all declared images
// ============================================================================

~std.compiler:command.declare {
    "name": "docker",
    "description": "Build Docker images from inline Dockerfile declarations"
}

~[comptime|command]pub event docker {
    program: *const Program,
    allocator: __koru_std.mem.Allocator,
    argv: []const []const u8,
}

~proc docker {
    const std = @import("std");

    // Parse subcommand
    var subcommand: []const u8 = "build";  // default
    if (argv.len > 0) {
        subcommand = argv[0];
    }

    if (!std.mem.eql(u8, subcommand, "build")) {
        std.debug.print("Usage: koruc <file>.kz docker build\n", .{});
        std.debug.print("       koruc <file>.kz docker list\n", .{});
        return;
    }

    // Collect all image declarations from AST
    const ImageDecl = struct {
        tag: []const u8,
        dockerfile: []const u8,
    };

    var images = std.ArrayListUnmanaged(ImageDecl){};
    defer images.deinit(allocator);

    for (program.items) |item| {
        if (item == .flow) {
            const flow = item.flow;
            if (flow.invocation.path.module_qualifier) |mq| {
                // Check for koru.docker:image
                if ((std.mem.eql(u8, mq, "koru.docker") or std.mem.eql(u8, mq, "docker")) and
                    flow.invocation.path.segments.len == 1 and
                    std.mem.eql(u8, flow.invocation.path.segments[0], "image"))
                {
                    var tag: []const u8 = "latest";
                    var dockerfile: []const u8 = "";

                    for (flow.invocation.args) |arg| {
                        if (std.mem.eql(u8, arg.name, "tag")) {
                            tag = arg.value;
                        } else if (std.mem.eql(u8, arg.name, "source")) {
                            dockerfile = arg.value;
                        }
                    }

                    if (dockerfile.len > 0) {
                        images.append(allocator, .{ .tag = tag, .dockerfile = dockerfile }) catch {
                            std.debug.print("Out of memory\n", .{});
                            return;
                        };
                    }
                }
            }
        }
    }

    if (images.items.len == 0) {
        std.debug.print("No Docker images declared.\n", .{});
        std.debug.print("Use: ~koru.docker:image(tag: \"myapp:latest\") {{ FROM alpine... }}\n", .{});
        return;
    }

    std.debug.print("\nBuilding {d} Docker image(s)...\n\n", .{images.items.len});

    // Create .koru-docker directory for generated Dockerfiles
    std.fs.cwd().makeDir(".koru-docker") catch |err| {
        if (err != error.PathAlreadyExists) {
            std.debug.print("Failed to create .koru-docker directory: {}\n", .{err});
            return;
        }
    };

    for (images.items, 0..) |img, idx| {
        std.debug.print("  [{d}/{d}] Building {s}...\n", .{ idx + 1, images.items.len, img.tag });

        // Generate Dockerfile
        const dockerfile_name = std.fmt.allocPrint(allocator, ".koru-docker/Dockerfile.{d}", .{idx}) catch {
            std.debug.print("    \x1b[31m✗\x1b[0m allocation failed\n", .{});
            continue;
        };
        defer allocator.free(dockerfile_name);

        const file = std.fs.cwd().createFile(dockerfile_name, .{}) catch |err| {
            std.debug.print("    \x1b[31m✗\x1b[0m failed to create {s}: {}\n", .{ dockerfile_name, err });
            continue;
        };
        file.writeAll(img.dockerfile) catch |err| {
            std.debug.print("    \x1b[31m✗\x1b[0m failed to write Dockerfile: {}\n", .{err});
            file.close();
            continue;
        };
        file.close();

        // Run docker build
        const result = std.process.Child.run(.{
            .allocator = allocator,
            .argv = &[_][]const u8{ "docker", "build", "-t", img.tag, "-f", dockerfile_name, "." },
        }) catch |err| {
            std.debug.print("    \x1b[31m✗\x1b[0m docker build failed: {}\n", .{err});
            continue;
        };
        defer allocator.free(result.stdout);
        defer allocator.free(result.stderr);

        if (result.term.Exited == 0) {
            std.debug.print("    \x1b[32m✓\x1b[0m built {s}\n", .{img.tag});
        } else {
            std.debug.print("    \x1b[31m✗\x1b[0m build failed (exit {d})\n", .{result.term.Exited});
            if (result.stderr.len > 0) {
                // Show last few lines of error
                var lines: usize = 0;
                var i = result.stderr.len;
                while (i > 0 and lines < 5) : (i -= 1) {
                    if (result.stderr[i - 1] == '\n') lines += 1;
                }
                std.debug.print("      {s}\n", .{result.stderr[i..]});
            }
        }
    }

    std.debug.print("\n", .{});
}

const std = @import("std");

// ============================================================================
// Types
// ============================================================================

pub const Image = struct {
    tag: []const u8,
    id: ?[]const u8,
};

pub const Container = struct {
    id: []const u8,
    image: []const u8,
};

// ============================================================================
// Declarative Image Definition (compile-time)
// ============================================================================

// Declare a Docker image - collected at compile time, generates Dockerfile
// Usage:
//   ~koru.docker:image(tag: "myapp:latest") {
//       FROM node:18-alpine
//       WORKDIR /app
//       COPY . .
//       CMD ["node", "index.js"]
//   }
~[comptime|norun]pub event image { tag: []const u8, source: Source }

~proc image {
    // Void event - collected during AST walking by docker command
}

// ============================================================================
// Build Operations
// ============================================================================

~pub event build { tag: []const u8, context: []const u8 }
| built { image: Image }
| failed { code: i32, msg: []const u8 }

~proc build {
    const allocator = std.heap.page_allocator;

    const result = std.process.Child.run(.{
        .allocator = allocator,
        .argv = &[_][]const u8{ "docker", "build", "-t", tag, context },
    }) catch |err| {
        return .{ .failed = .{ .code = -1, .msg = @errorName(err) } };
    };
    defer allocator.free(result.stdout);
    defer allocator.free(result.stderr);

    if (result.term.Exited != 0) {
        return .{ .failed = .{ .code = @intCast(result.term.Exited), .msg = result.stderr } };
    }

    return .{ .built = .{ .image = Image{ .tag = tag, .id = null } } };
}

// ============================================================================
// Container Lifecycle (with phantom obligations)
// ============================================================================

// Run a container - creates [running!] obligation that must be discharged
~pub event run { image: []const u8, name: ?[]const u8 }
| started { container: Container[running!] }
| failed { code: i32, msg: []const u8 }

~proc run {
    const allocator = std.heap.page_allocator;

    var argv_list = std.ArrayList([]const u8).init(allocator);
    defer argv_list.deinit();

    argv_list.appendSlice(&[_][]const u8{ "docker", "run", "-d" }) catch {
        return .{ .failed = .{ .code = -1, .msg = "out of memory" } };
    };

    if (name) |n| {
        argv_list.appendSlice(&[_][]const u8{ "--name", n }) catch {
            return .{ .failed = .{ .code = -1, .msg = "out of memory" } };
        };
    }

    argv_list.append(image) catch {
        return .{ .failed = .{ .code = -1, .msg = "out of memory" } };
    };

    const result = std.process.Child.run(.{
        .allocator = allocator,
        .argv = argv_list.items,
    }) catch |err| {
        return .{ .failed = .{ .code = -1, .msg = @errorName(err) } };
    };
    defer allocator.free(result.stdout);
    defer allocator.free(result.stderr);

    if (result.term.Exited != 0) {
        return .{ .failed = .{ .code = @intCast(result.term.Exited), .msg = result.stderr } };
    }

    // Container ID is in stdout (trimmed)
    const container_id = std.mem.trim(u8, result.stdout, "\n\r ");
    const id_copy = allocator.dupe(u8, container_id) catch {
        return .{ .failed = .{ .code = -1, .msg = "out of memory" } };
    };

    return .{ .started = .{ .container = Container{ .id = id_copy, .image = image } } };
}

// Stop a container - discharges [running!] obligation
~pub event stop { container: Container[!running] }
| stopped {}
| failed { code: i32, msg: []const u8 }

~proc stop {
    const allocator = std.heap.page_allocator;

    const result = std.process.Child.run(.{
        .allocator = allocator,
        .argv = &[_][]const u8{ "docker", "stop", container.id },
    }) catch |err| {
        return .{ .failed = .{ .code = -1, .msg = @errorName(err) } };
    };
    defer allocator.free(result.stdout);
    defer allocator.free(result.stderr);

    if (result.term.Exited != 0) {
        return .{ .failed = .{ .code = @intCast(result.term.Exited), .msg = result.stderr } };
    }

    return .{ .stopped = .{} };
}

// Kill a container (forceful) - also discharges [running!] obligation
~pub event kill { container: Container[!running] }
| killed {}
| failed { code: i32, msg: []const u8 }

~proc kill {
    const allocator = std.heap.page_allocator;

    const result = std.process.Child.run(.{
        .allocator = allocator,
        .argv = &[_][]const u8{ "docker", "kill", container.id },
    }) catch |err| {
        return .{ .failed = .{ .code = -1, .msg = @errorName(err) } };
    };
    defer allocator.free(result.stdout);
    defer allocator.free(result.stderr);

    if (result.term.Exited != 0) {
        return .{ .failed = .{ .code = @intCast(result.term.Exited), .msg = result.stderr } };
    }

    return .{ .killed = .{} };
}

// ============================================================================
// Registry Operations
// ============================================================================

~pub event push { image: []const u8 }
| pushed {}
| failed { code: i32, msg: []const u8 }

~proc push {
    const allocator = std.heap.page_allocator;

    const result = std.process.Child.run(.{
        .allocator = allocator,
        .argv = &[_][]const u8{ "docker", "push", image },
    }) catch |err| {
        return .{ .failed = .{ .code = -1, .msg = @errorName(err) } };
    };
    defer allocator.free(result.stdout);
    defer allocator.free(result.stderr);

    if (result.term.Exited != 0) {
        return .{ .failed = .{ .code = @intCast(result.term.Exited), .msg = result.stderr } };
    }

    return .{ .pushed = .{} };
}

~pub event pull { image: []const u8 }
| pulled {}
| failed { code: i32, msg: []const u8 }

~proc pull {
    const allocator = std.heap.page_allocator;

    const result = std.process.Child.run(.{
        .allocator = allocator,
        .argv = &[_][]const u8{ "docker", "pull", image },
    }) catch |err| {
        return .{ .failed = .{ .code = -1, .msg = @errorName(err) } };
    };
    defer allocator.free(result.stdout);
    defer allocator.free(result.stderr);

    if (result.term.Exited != 0) {
        return .{ .failed = .{ .code = @intCast(result.term.Exited), .msg = result.stderr } };
    }

    return .{ .pulled = .{} };
}
