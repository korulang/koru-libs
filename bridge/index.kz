// @koru/bridge - Persistent Sessions for Koru Execution
//
// A bridge holds state across interpreter invocations:
// - Session ID (for identification)
// - Handle pool (undischarged resources/obligations)
//
// Budget/rate limiting is the HOST APPLICATION'S concern, not the bridge's.
// The bridge just holds session state.
//
// Use cases:
// - Multi-tenant services (Orisha)
// - Interactive shells and REPLs
// - LLM tool-calling environments
// - Any long-running process that needs session isolation
//
// Usage:
//   ~import "@koru/bridge"
//
//   // In your host application's Zig code:
//   var manager = bridge.BridgeManager.init(allocator);
//   var session = try manager.getOrCreate("user-123");
//   // ... run interpreter with session.handle_pool ...

~[runtime]

~import "$std/interpreter"

const std = @import("std");

// Re-export interpreter types for convenience
pub const HandlePool = @import("root").koru_std.interpreter.HandlePool;
pub const Handle = @import("root").koru_std.interpreter.Handle;
pub const Value = @import("root").koru_std.interpreter.Value;
pub const InterpreterContext = @import("root").koru_std.interpreter.InterpreterContext;

// ============================================================================
// BRIDGE - A single persistent session
// ============================================================================

pub const Bridge = struct {
    /// Unique session identifier
    id: []const u8,
    /// Resource handles with obligations (persists across calls)
    handle_pool: HandlePool,
    /// Allocator for internal allocations
    allocator: std.mem.Allocator,

    pub fn init(allocator: std.mem.Allocator, id: []const u8) Bridge {
        return .{
            .id = allocator.dupe(u8, id) catch id,
            .handle_pool = HandlePool.init(allocator),
            .allocator = allocator,
        };
    }

    pub fn deinit(self: *Bridge) void {
        self.handle_pool.deinit();
    }

    /// Get handle count
    pub fn handleCount(self: *const Bridge) usize {
        return self.handle_pool.countUndischarged();
    }

    /// Get all undischarged handles
    pub fn getHandles(self: *const Bridge) []const Handle {
        return self.handle_pool.getUndischarged();
    }
};

// ============================================================================
// BRIDGE MANAGER - Dictionary of sessions
// ============================================================================

pub const BridgeManager = struct {
    bridges: std.StringHashMap(Bridge),
    allocator: std.mem.Allocator,

    pub fn init(allocator: std.mem.Allocator) BridgeManager {
        return .{
            .bridges = std.StringHashMap(Bridge).init(allocator),
            .allocator = allocator,
        };
    }

    pub fn deinit(self: *BridgeManager) void {
        var iter = self.bridges.valueIterator();
        while (iter.next()) |bridge| {
            bridge.deinit();
        }
        self.bridges.deinit();
    }

    /// Get or create a bridge for a session
    pub fn getOrCreate(self: *BridgeManager, session_id: []const u8) !*Bridge {
        if (self.bridges.getPtr(session_id)) |bridge| {
            return bridge;
        }

        // Create new bridge
        const id_copy = try self.allocator.dupe(u8, session_id);
        const bridge = Bridge.init(self.allocator, id_copy);
        try self.bridges.put(id_copy, bridge);
        return self.bridges.getPtr(id_copy).?;
    }

    /// Check if a session exists
    pub fn exists(self: *const BridgeManager, session_id: []const u8) bool {
        return self.bridges.contains(session_id);
    }

    /// Get a bridge (returns null if not found)
    pub fn get(self: *BridgeManager, session_id: []const u8) ?*Bridge {
        return self.bridges.getPtr(session_id);
    }

    /// End a session - returns undischarged handles for cleanup
    /// Caller is responsible for calling discharge events on returned handles
    pub fn end(self: *BridgeManager, session_id: []const u8) ?[]const Handle {
        if (self.bridges.fetchRemove(session_id)) |entry| {
            var bridge = entry.value;
            const handles = bridge.getHandles();
            // Note: We return handles but don't deinit the pool yet
            // The caller should process these handles then call deinit
            return handles;
        }
        return null;
    }

    /// Get total active session count
    pub fn sessionCount(self: *const BridgeManager) usize {
        return self.bridges.count();
    }
};
