// Koru Vaxis Library - Reactive TUI wrapper
// ==========================================
//
// Wraps libvaxis for Koru, exposing terminal events
// as a reactive event stream that can be tapped.
//
// PATTERN: Dumb pump loop + smart taps
//   - poll() runs in a loop with null transitions
//   - User code taps poll to react to events
//   - Multicast for free - multiple taps can observe
//
// USAGE:
//   ~import "$app/vaxis"
//   ~import "$std/taps"
//
//   ~tap(vaxis:poll -> *)
//   | key k when(k.char == 'q') |> vaxis:quit()
//
//   ~vaxis:run(title: "My App")
//   | ready |> @loop()

// Build system dependency - libvaxis from Zig package manager
~import "$std/build"
~import "$std/deps"

// Zig package dependency - URL+hash for build.zig.zon generation
~std.deps:requires.zig {
    "name": "vaxis",
    "url": "git+https://github.com/rockorager/libvaxis.git#75035b169e91a51c233f3742161f8eb8eafca659",
    "hash": "vaxis-0.5.1-BWNV_IE-CQBYmSf_boEKUyv6den0Gmj5LksxvdCx2pBL"
}

// For BACKEND compilation (so it can validate the generated code)
~std.compiler:requires {
    const vaxis_dep = b.dependency("vaxis", .{
        .target = target,
        .optimize = optimize,
    });
    exe.root_module.addImport("vaxis", vaxis_dep.module("vaxis"));
}

// For OUTPUT binary (the final executable)
~std.build:requires {
    const vaxis_dep = b.dependency("vaxis", .{
        .target = target,
        .optimize = optimize,
    });
    exe.root_module.addImport("vaxis", vaxis_dep.module("vaxis"));
}

const std = @import("std");
const vaxis = @import("vaxis");

// Phantom handle for TTY lifecycle tracking
// The actual state is global, but this handle carries the obligation
const TtyHandle = struct { _phantom: u8 = 0 };

// Zig types for event payloads
const KeyMods = struct {
    ctrl: bool = false,
    alt: bool = false,
    shift: bool = false,
    super_key: bool = false,
};

const KeyData = struct {
    codepoint: u21,
    char: ?u8,
    mods: KeyMods,
};

const SizeData = struct {
    width: u16,
    height: u16,
};

// Runtime state
var vx: vaxis.Vaxis = undefined;
var tty: vaxis.Tty = undefined;
var event_loop: vaxis.Loop(VaxisEvent) = undefined;
var is_initialized: bool = false;
var should_quit: bool = false;
var alloc: std.mem.Allocator = undefined;
var tty_buffer: [4096]u8 = undefined; // Buffer for TTY init

// Internal event type for vaxis loop
// NOTE: key_release removed - terminal responses to queryTerminal come as key events
const VaxisEvent = union(enum) {
    key_press: vaxis.Key,
    winsize: vaxis.Winsize,
    focus_in,
    focus_out,
};

// ============================================================================
// EVENT DEFINITIONS
// ============================================================================

// The poll event - returns terminal events
~pub event poll {}
| key { data: KeyData }
| resize { size: SizeData }
| focus_in {}
| focus_out {}
| quit {}

~proc poll {
    if (should_quit or !is_initialized) {
        return .{ .quit = .{} };
    }

    while (true) {
        const event = event_loop.nextEvent();

        switch (event) {
            .key_press => |k| {
                // Skip terminal response keys (high codepoints from capability queries)
                if (k.codepoint > 0x3000 or k.codepoint == 0) continue;

                return .{ .key = .{
                    .data = .{
                        .codepoint = k.codepoint,
                        .char = if (k.codepoint < 128 and k.codepoint > 0) @intCast(k.codepoint) else null,
                        .mods = .{
                            .ctrl = k.mods.ctrl,
                            .alt = k.mods.alt,
                            .shift = k.mods.shift,
                            .super_key = k.mods.super,
                        },
                    },
                }};
            },
            .winsize => |ws| {
                vx.resize(alloc, tty.writer(), ws) catch {};
                return .{ .resize = .{
                    .size = .{
                        .width = ws.cols,
                        .height = ws.rows,
                    },
                }};
            },
            .focus_in => return .{ .focus_in = .{} },
            .focus_out => return .{ .focus_out = .{} },
        }
    }
}

// Initialize vaxis - produces tty_initialized obligation that MUST be cleaned up
~pub event run { title: []const u8 }
| ready { tty: TtyHandle[tty_initialized!] }
| err { message: []const u8 }

~proc run {
    alloc = std.heap.page_allocator;

    // Initialize TTY
    tty = vaxis.Tty.init(&tty_buffer) catch |e| {
        return .{ .err = .{ .message = @errorName(e) } };
    };

    // Initialize Vaxis
    vx = vaxis.init(alloc, .{}) catch |e| {
        return .{ .err = .{ .message = @errorName(e) } };
    };

    // Initialize event loop
    event_loop = .{ .vaxis = &vx, .tty = &tty };
    event_loop.init() catch |e| {
        return .{ .err = .{ .message = @errorName(e) } };
    };
    event_loop.start() catch |e| {
        return .{ .err = .{ .message = @errorName(e) } };
    };

    // Enter alt screen and query terminal capabilities
    vx.enterAltScreen(tty.writer()) catch {};
    vx.queryTerminal(tty.writer(), 1 * std.time.ns_per_s) catch {};

    // CRITICAL: Wait for initial resize to size the window buffers
    // Without this, window is 0x0 and nothing renders!
    while (true) {
        const event = event_loop.nextEvent();
        switch (event) {
            .winsize => |ws| {
                vx.resize(alloc, tty.writer(), ws) catch {};
                break;
            },
            else => {},  // Skip terminal response keys etc
        }
    }

    is_initialized = true;
    return .{ .ready = .{ .tty = .{} } };
}

// Request quit
~pub event quit {}

~proc quit {
    should_quit = true;
}

// Clean up - consumes tty_initialized obligation
~pub event cleanup { handle: TtyHandle[!tty_initialized] }

~proc cleanup {
    if (is_initialized) {
        vx.deinit(alloc, tty.writer());
        tty.deinit();
        is_initialized = false;
    }
}

// Render to screen
~pub event render {}

~proc render {
    if (is_initialized) {
        vx.render(tty.writer()) catch {};
    }
}

// Clear screen
~pub event clear {}

~proc clear {
    if (is_initialized) {
        const win = vx.window();
        win.clear();
    }
}

// Write text at position
~pub event write_at { x: u16, y: u16, text: []const u8 }

// Display key info at position (formatted for demos)
~pub event show_key { x: u16, y: u16, k: KeyData }

~proc write_at {
    if (is_initialized) {
        const win = vx.window();
        const child = win.child(.{ .x_off = x, .y_off = y });
        for (text, 0..) |_, i| {
            child.writeCell(@intCast(i), 0, .{
                .char = .{ .grapheme = text[i .. i + 1] },
            });
        }
    }
}

~proc show_key {
    if (is_initialized) {
        const win = vx.window();
        const child = win.child(.{ .x_off = x, .y_off = y });

        var buf: [64]u8 = undefined;
        var mods_buf: [32]u8 = undefined;
        var mods_len: usize = 0;

        if (k.mods.ctrl) {
            @memcpy(mods_buf[mods_len..][0..6], "[ctrl]");
            mods_len += 6;
        }
        if (k.mods.alt) {
            @memcpy(mods_buf[mods_len..][0..5], "[alt]");
            mods_len += 5;
        }
        if (k.mods.shift) {
            @memcpy(mods_buf[mods_len..][0..7], "[shift]");
            mods_len += 7;
        }
        if (k.mods.super_key) {
            @memcpy(mods_buf[mods_len..][0..7], "[super]");
            mods_len += 7;
        }

        const char_display: u8 = if (k.char) |c| (if (c >= 32 and c < 127) c else '.') else '.';
        const mods_str = mods_buf[0..mods_len];

        const formatted = std.fmt.bufPrint(&buf, "Key: {c}  Code: {d:<5}  {s}", .{
            char_display,
            k.codepoint,
            mods_str,
        }) catch "?";

        for (formatted, 0..) |_, i| {
            child.writeCell(@intCast(i), 0, .{
                .char = .{ .grapheme = formatted[i .. i + 1] },
            });
        }
    }
}
