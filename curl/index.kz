// @koru/curl - HTTP Client for Koru
//
// Wraps industry-standard libcurl with phantom obligation types
// to enforce connection cleanup at compile-time.

~import "$std/build"

~std.build:requires {
    exe.linkSystemLibrary("curl");
    exe.linkLibC();
}

const std = @import("std");
const c = @cImport({
    @cInclude("curl/curl.h");
});

// ============================================================================
// Types
// ============================================================================

pub const Response = struct {
    handle: ?*c.CURL,
    allocator: std.mem.Allocator,
    status: i32,
    body: []u8,
};

pub const Error = struct {
    code: i32,
    msg: []const u8,
};

// Callback context - holds both buffer and allocator for Zig 0.15 API
const WriteContext = struct {
    buffer: std.ArrayListUnmanaged(u8),
    allocator: std.mem.Allocator,
};

fn writeCallback(ptr: [*c]u8, size: c_uint, nmemb: c_uint, userdata: ?*anyopaque) callconv(.c) c_uint {
    const real_size = size * nmemb;
    if (userdata) |ud| {
        const ctx: *WriteContext = @ptrCast(@alignCast(ud));
        ctx.buffer.appendSlice(ctx.allocator, ptr[0..real_size]) catch return 0;
    }
    return real_size;
}

fn curlError(code: c.CURLcode, allocator: std.mem.Allocator) Error {
    const msg = c.curl_easy_strerror(code);
    const duped = allocator.dupe(u8, std.mem.span(msg)) catch "allocation failed";
    return .{ .code = @intCast(code), .msg = duped };
}

// ============================================================================
// GET Request
// ============================================================================

~pub event get { url: []const u8, allocator: std.mem.Allocator }
| ok { resp: *Response[open!] }
| err Error

~proc get {
    const handle = c.curl_easy_init();
    if (handle == null) {
        return .{ .err = .{ .code = @intCast(c.CURLE_FAILED_INIT), .msg = "Failed to initialize curl" } };
    }
    errdefer _ = c.curl_easy_cleanup(handle);

    // Set URL
    _ = c.curl_easy_setopt(handle, c.CURLOPT_URL, url.ptr);
    _ = c.curl_easy_setopt(handle, c.CURLOPT_FOLLOWLOCATION, @as(c_long, 1));

    // Response buffer with allocator context
    var write_ctx = WriteContext{
        .buffer = std.ArrayListUnmanaged(u8){},
        .allocator = allocator,
    };

    _ = c.curl_easy_setopt(handle, c.CURLOPT_WRITEFUNCTION, writeCallback);
    _ = c.curl_easy_setopt(handle, c.CURLOPT_WRITEDATA, &write_ctx);

    // Perform request
    const result = c.curl_easy_perform(handle);
    if (result != c.CURLE_OK) {
        write_ctx.buffer.deinit(allocator);
        return .{ .err = curlError(result, allocator) };
    }

    // Get HTTP status code
    var http_code: c_long = 0;
    _ = c.curl_easy_getinfo(handle, c.CURLINFO_RESPONSE_CODE, &http_code);

    // Create response
    const resp = allocator.create(Response) catch {
        write_ctx.buffer.deinit(allocator);
        _ = c.curl_easy_cleanup(handle);
        return .{ .err = .{ .code = -1, .msg = "allocation failed" } };
    };
    resp.* = .{
        .handle = handle,
        .allocator = allocator,
        .status = @intCast(http_code),
        .body = write_ctx.buffer.toOwnedSlice(allocator) catch &[_]u8{},
    };

    return .{ .ok = .{ .resp = resp } };
}

// ============================================================================
// POST Request
// ============================================================================

~pub event post { url: []const u8, body: []const u8, allocator: std.mem.Allocator }
| ok { resp: *Response[open!] }
| err Error

~proc post {
    const handle = c.curl_easy_init();
    if (handle == null) {
        return .{ .err = .{ .code = @intCast(c.CURLE_FAILED_INIT), .msg = "Failed to initialize curl" } };
    }
    errdefer _ = c.curl_easy_cleanup(handle);

    // Set URL and POST
    _ = c.curl_easy_setopt(handle, c.CURLOPT_URL, url.ptr);
    _ = c.curl_easy_setopt(handle, c.CURLOPT_POST, @as(c_long, 1));
    _ = c.curl_easy_setopt(handle, c.CURLOPT_POSTFIELDS, body.ptr);
    _ = c.curl_easy_setopt(handle, c.CURLOPT_POSTFIELDSIZE, @as(c_long, @intCast(body.len)));

    // Response buffer with allocator context
    var write_ctx = WriteContext{
        .buffer = std.ArrayListUnmanaged(u8){},
        .allocator = allocator,
    };

    _ = c.curl_easy_setopt(handle, c.CURLOPT_WRITEFUNCTION, writeCallback);
    _ = c.curl_easy_setopt(handle, c.CURLOPT_WRITEDATA, &write_ctx);

    // Perform request
    const result = c.curl_easy_perform(handle);
    if (result != c.CURLE_OK) {
        write_ctx.buffer.deinit(allocator);
        return .{ .err = curlError(result, allocator) };
    }

    // Get HTTP status code
    var http_code: c_long = 0;
    _ = c.curl_easy_getinfo(handle, c.CURLINFO_RESPONSE_CODE, &http_code);

    // Create response
    const resp = allocator.create(Response) catch {
        write_ctx.buffer.deinit(allocator);
        _ = c.curl_easy_cleanup(handle);
        return .{ .err = .{ .code = -1, .msg = "allocation failed" } };
    };
    resp.* = .{
        .handle = handle,
        .allocator = allocator,
        .status = @intCast(http_code),
        .body = write_ctx.buffer.toOwnedSlice(allocator) catch &[_]u8{},
    };

    return .{ .ok = .{ .resp = resp } };
}

// ============================================================================
// Close (discharges obligation)
// ============================================================================

~pub event close { resp: *Response[!open] }

~proc close {
    // Clean up curl handle
    if (resp.handle) |h| {
        c.curl_easy_cleanup(h);
    }
    // Free body memory
    if (resp.body.len > 0) {
        resp.allocator.free(resp.body);
    }
    // Free response struct
    resp.allocator.destroy(resp);
}
